/**
 * PARSER ARITMETICO 
 * Camilo Salinas
 * Camila Londo√±o
 */

options {
  IGNORE_CASE = false;
  STATIC = false;
}
PARSER_BEGIN(ParserRegex)
package uniandes.teolen.parserJavaCC.parserRegex;

import java.util.*;
 
public class ParserRegex {
    public List<String> variables = new ArrayList<String>();
    public List<String> funciones = new ArrayList<String>();
    
} 

PARSER_END(ParserRegex)

SKIP :
{
    " " | "\r" | "\t" | "\n"

}
TOKEN : /* OPERATORS */
{
    < ASIGNACION: "=" >
|   < VAR: "VAR" >
|   < MENOR: "<" >
|   < MAYOR: ">" >
|   < MENORIGUAL: "<=" >
|   < MAYORIGUAL: " >=" >
|   < IGUAL: "==" >
|   < DIFERENTE: "!=" >
|   < DEF: "define" >
|   < PRINT: "print" >
|   < IFStatement: "if">
|   < NOT: "not" >
|   < AND: "and" >
|   < OR: "or" >
|   < FALSE:"false" >
|   < TRUE: "true" >
|	< SUMA >: "+">
|	< RESTA >: "-">
|	< MULTIPLICACION >: "*">
|	< DIVISION >: "/">


}

TOKEN :
{
    < #DIGIT: ["0"-"9"] >
|   < #MAY : ["A"-"Z"] >
|   < #MIN : ["a"-"z"] >
|   < VARIABLE :  <MAY > | < MIN > (<MAY > | < MIN >| < DIGIT >)* >
|   < FUNCION: (<MAY>|<MIN>|< DIGIT >)+ >


}
void expsRegs():
{}
{
  (define()|declararVariable())+ print()		  
}
void define():
{}
{
  
  <DEF>addFuncion()"("params()")" ":" (arithmeticExpression()|ifFunction() ) 
  
}
void params():
{}
{
	(variable()",")* | variable()  
}
void arithmeticExpression()
{}
{
	exp()
}

void ifFunction() :
{}
{
    <IFStatement> "(" negacion() "," (exp()|ifFunction()) "," (exp()|ifFunction())")"
}
 
void orUnir():
{}
{
    andUnir()  (<OR> andUnir())*
}

void andUnir():
{}
{
    negacion()(<AND> negacion())*
}

void negacion():
{}//(num==0 AND num==1 ) != ( )
{     
    <NOT> ? (
        (exp()
        (<MAYOR>|<MENOR>|<MENORIGUAL>|<MAYORIGUAL>|<IGUAL>|<DIFERENTE>)
        exp())  | 
        "("orUnir()")")+
}

void print():
{}
{
    <PRINT> "(" (funcion()|variable()|exp())+ ")"
}
void declararVariable():
{}
{
    <VAR> addNombreVariable() <EQUAL> valorVariable()
}
void exp() :
{}
{
// Parses  E -> E + T
//         E -> E - T
//         E -> T
//   in EBNF:  E -> T {+ T   | - T }
 term() ( < PLUS > term() | < MINUS > term() )*
}

void term() :
{}
{
// Parses  T -> T * F
//         T -> T / F
//         T -> F
//   in EBNF:  T -> F {* F   | /  F }
 fact() ( < MULTIPLY > fact() | < DIVIDE > fact() )*
}
void fact() :
{
// Parses  F -> B
//         F -> -B
//         B -> num
//         B -> '(' E ')'
//   in EBNF:  F -> [-](num |'(' E ')')
}
{
(< MINUS >)? (num()| "(" exp() ")"|variable()|"["exp()"]")
}

void ifFunction():
{}
{
  "{"(addSymbolAlphabet())("," addSymbolAlphabet())*"}"
}


void addFuncion() throws Error :
{
    Token funcion;
}
{
    (funcion = <FUNCION>)
    {
        boolean centinela = false;
        for(int i = 0; i < funciones.size() && !centinela; i++)
        {
              if(funcion.get(i).equals(funcion.image))
              {
                 centinela = true;
                 throw new Error("La funcion:" + funcion.image+"ya existe.");
              }
        }
        if(!centinela)
        {         
            funciones.add(funcion.image);
        }

    }
}
void addNombreVariable():
{
    Token variable;
}
{
    (variable = <VARIABLE>)
    {
        boolean centinela = false;
        for(int i = 0; i < variables.size() && !centinela; i++)
        {
              if(variables.get(i).equals(variable.image))
              {
                 centinela = true;
                 throw new Error("La variable: " + variable.image+" ya existe.");
              }
        }
        if(!centinela)
        {         
            variables.add(variable.image);
        }

    }
}


void expresion():
{
}
{
    ((expresionPeque())(<PLUS>|<MULTIPLY>))     
}
void expresionPeque():
{
}
{
  funcionDeclarada()|variableDeclarada()|< CADENAVACIA >|< VACIO >|"("expresion()")"
}
void funcionDeclarada():
{
    Token funcion;
}
{
  (funcion = <FUNCION>)
    {
        boolean centinela = false;
        for(int i = 0; i < alphabet.size() && !centinela; i++)
        {
              if(funciones.get(i).equals(funcion.image))
              {
                 centinela = true;
              }
        }
        if(!centinela)
        {         
            throw new Error("La funcion:" + funcion.image+"no ha sido declarada.");
        }

    }
}
void variable():
{
  Token variable;
}
{
  (variable = <VARIABLE>)
    {
        boolean centinela = false;
        for(int i = 0; i < variables.size() && !centinela; i++)
        {
              if(variables.get(i).equals(variable.image))
              {
                 centinela = true;
                 
              }
        }
        if(!centinela)
        {         
            throw new Error("La variable:" + variable.image+"no ha sido declarado en el alfabeto.");
        }

    }
}

